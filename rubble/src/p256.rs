//! P-256 crypto operations.
//!
//! BLE uses P-256 for pairing. This module provides an interface for plugging in different
//! implementations of the P-256 operations. The main consumer of this module is the [`security`]
//! module; refer to that for more info about pairing and encryption in BLE.
//!
//! The primary trait in this module is [`P256Provider`]. Rubble comes with 2 built-in
//! implementations of that trait, which can be enabled via these Cargo features:
//!
//! * **`ring`**: Enables the [`RingProvider`] and [`RingSecretKey`] types, which use the
//!   [*ring* library][ring]. Note that *ring* does not support `#![no_std]` operation, so this is
//!   mostly useful for tests and other non-embedded usage.
//! * **`nisty`**: Enables [`NistyProvider`] and [`NistySecretKey`], which use the [nisty] crate and
//!   [micro-ecc] library. Nisty currently supports Cortex-M4 and Cortex-M33 MCUs.
//!
//! [`security`]: ../security/index.html
//! [`P256Provider`]: trait.P256Provider.html
//! [`RingProvider`]: struct.RingProvider.html
//! [`RingSecretKey`]: struct.RingSecretKey.html
//! [ring]: https://github.com/briansmith/ring
//! [`NistyProvider`]: struct.NistyProvider.html
//! [`NistySecretKey`]: struct.NistySecretKey.html
//! [nisty]: https://github.com/nickray/nisty
//! [micro-ecc]: https://github.com/kmackay/micro-ecc

/// A P-256 public key (point on the curve) in uncompressed format.
///
/// The encoding is as specified in *[SEC 1: Elliptic Curve Cryptography]*, but without the leading
/// byte: The first 32 Bytes are the big-endian encoding of the point's X coordinate, and the
/// remaining 32 Bytes are the Y coordinate, encoded the same way.
///
/// [SEC 1: Elliptic Curve Cryptography]: http://www.secg.org/sec1-v2.pdf
pub struct PublicKey(pub [u8; 64]);

/// A shared secret resulting from an ECDH key agreement.
///
/// This is returned by implementations of [`SecretKey::agree`].
///
/// [`SecretKey::agree`]: trait.SecretKey.html#tymethod.agree
pub struct SharedSecret(pub [u8; 32]);

/// Trait for P-256 operation providers.
pub trait P256Provider {
    /// Provider-defined secret key type.
    type SecretKey: SecretKey;

    /// Generates a P-256 key pair using cryptographically strong randomness.
    fn generate_keypair(&mut self) -> (Self::SecretKey, PublicKey);
}

/// Secret key operations required by Rubble.
///
/// This API imposes no requirements on the representation or location of secret keys. This means
/// that it should be possible to implement this trait even for keys stored in some secure key
/// storage like a smartcard.
pub trait SecretKey: Sized {
    /// Performs ECDH key agreement using an ephemeral secret key `self` and the public key of the
    /// other party.
    ///
    /// Here, "ephemeral" just means that this method takes `self` by value. This allows
    /// implementing `SecretKey` for providers that enforce single-use keys using Rust ownership
    /// (like *ring*).
    fn agree(self, foreign_key: &PublicKey) -> SharedSecret;
}

#[cfg(feature = "ring")]
pub use self::ring::*;

#[cfg(feature = "ring")]
mod ring {
    use {
        super::*,
        ::ring::{
            agreement::{agree_ephemeral, EphemeralPrivateKey, UnparsedPublicKey, ECDH_P256},
            rand::SystemRandom,
        },
    };

    /// A P-256 provider that uses *ring* under the hood.
    pub struct RingProvider {
        rng: SystemRandom,
    }

    impl RingProvider {
        /// Creates a new `RingProvider` that uses the system's RNG for key generation.
        pub fn new() -> Self {
            Self {
                rng: SystemRandom::new(),
            }
        }
    }

    impl P256Provider for RingProvider {
        type SecretKey = RingSecretKey;

        fn generate_keypair(&mut self) -> (Self::SecretKey, PublicKey) {
            let secret = EphemeralPrivateKey::generate(&ECDH_P256, &self.rng).unwrap();
            let public = secret.compute_public_key().unwrap();

            let mut pub_bytes = [0; 64];
            // Strip the first octet (indicates the key type; see RFC 5480)
            pub_bytes.copy_from_slice(&public.as_ref()[1..]);

            let secret = RingSecretKey(secret);
            let public = PublicKey(pub_bytes);

            (secret, public)
        }
    }

    /// A secret key generated by a `RingProvider`.
    pub struct RingSecretKey(EphemeralPrivateKey);

    impl SecretKey for RingSecretKey {
        fn agree(self, foreign_key: &PublicKey) -> SharedSecret {
            // Convert `foreign_key` to ring's format:
            let mut encoded = [0; 65];
            encoded[0] = 0x04; // indicates uncompressed format (see RFC 5480)
            encoded[1..].copy_from_slice(&foreign_key.0);
            let public = UnparsedPublicKey::new(&ECDH_P256, &encoded[..]);

            let mut shared_secret = [0; 32];
            agree_ephemeral(self.0, &public, (), |b| {
                shared_secret.copy_from_slice(b);
                Ok(())
            })
            .unwrap();

            SharedSecret(shared_secret)
        }
    }
}

#[cfg(feature = "nisty")]
pub use self::nisty::*;

#[cfg(feature = "nisty")]
mod nisty {
    use {
        super::*,
        rand_core::{CryptoRng, RngCore},
    };

    /// A P-256 operation provider using nisty / micro-ecc under the hood.
    pub struct NistyProvider<R: CryptoRng + RngCore> {
        rng: R,
    }

    impl<R: CryptoRng + RngCore> NistyProvider<R> {
        /// Creates a new nisty P-256 provider using `rng` for key generation.
        pub fn new(rng: R) -> Self {
            Self { rng }
        }
    }

    impl<R: CryptoRng + RngCore> P256Provider for NistyProvider<R> {
        type SecretKey = NistySecretKey;

        /// Generates a P-256 key pair using a 32-byte seed generated by `R`.
        fn generate_keypair(&mut self) -> (Self::SecretKey, PublicKey) {
            let mut seed = [0; 32];
            self.rng.fill_bytes(&mut seed);

            let keypair = ::nisty::Keypair::generate_patiently(&seed);
            let (secret, public) = keypair.split();

            let secret = NistySecretKey(secret);
            let public = PublicKey(public.to_bytes());

            (secret, public)
        }
    }

    /// A secret key generated by a `NistyProvider`.
    pub struct NistySecretKey(::nisty::SecretKey);

    impl SecretKey for NistySecretKey {
        fn agree(self, foreign_key: &PublicKey) -> SharedSecret {
            let public = ::nisty::PublicKey::try_from_bytes(&foreign_key.0).unwrap();
            let shared_secret = self.0.agree(&public).unwrap().to_bytes();
            SharedSecret(shared_secret)
        }
    }
}

#[cfg(test)]
mod tests {
    use {
        nisty::{Keypair, PublicKey},
        ring::{
            agreement::{agree_ephemeral, EphemeralPrivateKey, UnparsedPublicKey, ECDH_P256},
            rand::SystemRandom,
        },
    };

    /// Performs ECDH key agreement between ring and nisty.
    ///
    /// This involves generating key pairs and converting the public keys to the format expected by
    /// the other library. It serves as a sort of sanity check, to ensure that such a key agreement
    /// is possible.
    #[test]
    fn raw_ring_nisty_agreement() {
        // Generate a nisty key pair by iterating a fixed seed. It doesn't matter which key we use
        // here.
        const NISTY_SEED: [u8; 32] = [0xAA; 32];
        let n_pair = nisty::Keypair::generate_patiently(NISTY_SEED);
        let (n_secret, n_public) = n_pair.split();

        // Now generate the ring key pair.
        let rng = SystemRandom::new();
        let r_secret = EphemeralPrivateKey::generate(&ECDH_P256, &rng).unwrap();
        let r_public = r_secret.compute_public_key().unwrap();

        // Convert the nisty public key to ring's expected format.
        let mut encoded = [0; 65];
        encoded[0] = 0x04; // uncompressed
        encoded[1..].copy_from_slice(n_public.as_bytes());
        let n_public = UnparsedPublicKey::new(&ECDH_P256, &encoded[..]);

        // Convert ring's public key to nisty's expected format.
        let mut bytes = [0; 64];
        bytes.copy_from_slice(&r_public.as_ref()[1..]);
        let r_public = nisty::PublicKey::try_from_bytes(&bytes).unwrap();

        // Do the ring-side agreement.
        let mut r_shared = [0; 32];
        agree_ephemeral(r_secret, &n_public, (), |b| {
            r_shared.copy_from_slice(b);
            Ok(())
        })
        .unwrap();

        // Do the nisty-side agreement.
        let n_shared = n_secret.agree(&r_public).unwrap().to_bytes();

        // The derived secret must be identical, or we messed something up.
        assert_eq!(r_shared, n_shared);
    }

    /// Performs key agreement between the ring and nisty `P256Provider` implementations.
    ///
    /// This uses the Rubble API, so the `ring` and `nisty` Cargo features must be enabled for the
    /// test to work.
    #[test]
    #[cfg(all(feature = "ring", feature = "nisty"))]
    fn ring_nisty_agreement() {
        use super::{NistyProvider, P256Provider, RingProvider, SecretKey};
        use rand_core::{CryptoRng, RngCore};

        // Pretend-RNG that returns a constant value. Do not do this outside of tests.
        struct Rng;

        impl RngCore for Rng {
            fn next_u32(&mut self) -> u32 {
                0xAAAAAAAA
            }
            fn next_u64(&mut self) -> u64 {
                0xAAAAAAAAAAAAAAAA
            }
            fn fill_bytes(&mut self, dest: &mut [u8]) {
                for byte in dest {
                    *byte = 0xAA;
                }
            }
            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
                self.fill_bytes(dest);
                Ok(())
            }
        }

        impl CryptoRng for Rng {}

        let mut ring = RingProvider::new();
        let (r_secret, r_public) = ring.generate_keypair();

        let mut nisty = NistyProvider::new(Rng);
        let (n_secret, n_public) = nisty.generate_keypair();

        let r_shared = r_secret.agree(&n_public);
        let n_shared = n_secret.agree(&r_public);

        assert_eq!(r_shared.0, n_shared.0);
    }

    #[test]
    #[cfg(not(all(feature = "ring", feature = "nisty")))]
    #[ignore]
    fn ring_nisty_agreement() {
        panic!("this test requires the `ring` and `nisty` features to be enabled");
    }

    /// Uses nisty to verify the Bluetooth test vectors.
    ///
    /// See "7.1.2 P-256 sample data" in the spec.
    #[test]
    fn nisty_test_vectors() {
        fn parse_into(mut slice: &mut [u8], s: &str) {
            for s_word in s.split_whitespace() {
                assert_eq!(s_word.len(), 8);

                let target = &mut slice[..4];
                for i in 0..4 {
                    target[i] = u8::from_str_radix(&s_word[i * 2..i * 2 + 2], 16).unwrap();
                }
                slice = &mut slice[4..];
            }

            assert!(slice.is_empty());
        }

        // Strings copied straight from the spec
        const PRIV_A: &str =
            "3f49f6d4 a3c55f38 74c9b3e3 d2103f50 4aff607b eb40b799 5899b8a6 cd3c1abd";
        const PUB_A_X: &str =
            "20b003d2 f297be2c 5e2c83a7 e9f9a5b9 eff49111 acf4fddb cc030148 0e359de6";
        const PUB_A_Y: &str =
            "dc809c49 652aeb6d 63329abf 5a52155c 766345c2 8fed3024 741c8ed0 1589d28b";

        const PRIV_B: &str =
            "55188b3d 32f6bb9a 900afcfb eed4e72a 59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd";
        const PUB_B_X: &str =
            "1ea1f0f0 1faf1d96 09592284 f19e4c00 47b58afd 8615a69f 559077b2 2faaa190";
        const PUB_B_Y: &str =
            "4c55f33e 429dad37 7356703a 9ab85160 472d1130 e28e3676 5f89aff9 15b1214a";

        const DHKEY: &str =
            "ec0234a3 57c8ad05 341010a6 0a397d9b 99796b13 b4f866f1 868d34f3 73bfa698";

        let mut priv_a = [0; 32];
        parse_into(&mut priv_a, PRIV_A);
        let key_a = Keypair::try_from_bytes(&priv_a).unwrap();

        let mut pub_a_bytes = [0; 64];
        parse_into(&mut pub_a_bytes[..32], PUB_A_X);
        parse_into(&mut pub_a_bytes[32..], PUB_A_Y);
        let pub_a = PublicKey::try_from_bytes(&pub_a_bytes).unwrap();

        assert_eq!(key_a.public, pub_a);

        let mut priv_b = [0; 32];
        parse_into(&mut priv_b, PRIV_B);
        let key_b = Keypair::try_from_bytes(&priv_b).unwrap();

        let mut pub_b_bytes = [0; 64];
        parse_into(&mut pub_b_bytes[..32], PUB_B_X);
        parse_into(&mut pub_b_bytes[32..], PUB_B_Y);
        let pub_b = PublicKey::try_from_bytes(&pub_b_bytes).unwrap();

        assert_eq!(key_b.public, pub_b);

        let shared_a = key_a.secret.agree(&pub_b).unwrap();
        let shared_b = key_b.secret.agree(&pub_a).unwrap();
        let mut dhkey = [0; 32];
        parse_into(&mut dhkey, DHKEY);
        assert_eq!(shared_a, shared_b);
        assert_eq!(shared_a.as_bytes(), &dhkey);
    }
}
